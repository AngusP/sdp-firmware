%
%  FIRMWARE TECHNICAL SPECIFICATION
%

\section{Firmware}

\subsection{Important Source Files}

\paragraph{\texttt{firmware.ino}}
This is the main file which contains the \texttt{void setup()} and \texttt{void loop()} functions. The former only initializes the serial port, calls the \texttt{setup()} methods of other pivotal objects, and outputs \texttt{STARTUP} to indicate that the robot is ready to receive commands. On the other hand, the \texttt{loop} function handles asynchronous logic by checking the serial port for any new commands and synchronous logic by running processes (more on these below).

\paragraph{\texttt{SerialCommand.cpp}} This file provides a simple library whose purpose is to map command strings to callbacks which it then executes based on the input it reads from the serial port.

\paragraph{\texttt{CommandSet.cpp}} This object initializes \texttt{SerialCommand} and associates each of the robot's commands with one of its methods, which then perform the necessary steps to fulfil it.

\paragraph{\texttt{Processes.cpp}} The object in this file manages processes, which are essentially tasks to be completed periodically but not necessarily as often as the \texttt{loop()} function is called. 

\paragraph{\texttt{State.cpp}} This is a very simple object which essentially only serves as a central storage space for various values which may change during runtime. Most notably, it contains the current information on each of the holonomic motors such as power or total distance travelled, and the state of a data transfer.

\paragraph{\texttt{robot.cpp}} Contains the code that is run clock-synchronously by Processes -- There is a process that is responsible for toggling an LED every second in order to indicate the robot is \textit{alive}. Other processes include one that polls the encoders on each motor to monitor how far they travelled and another one that potentially makes any adjustments necessary to account for errors or motor differences based on this information.

\paragraph{\texttt{SDPArduino.cpp}} This is a library based on the last year's winner team's firmware which declares several low-level utility functions providing convenient interface for bidirectional motor movement and halting.

\subsection{Architecture}

The firmware we're currently running has changed significantly from the source we started with (SDP Group 13 2015). Some useful concepts have survived, but the implementation is significantly different, and the majority of changes have been made to generalise the control structures and add powerful flexibility to the firmware's capabilities.

The notion of `Processes' has been introduced, allowing a structure to define a task that must be run at a defined time interval. Process structures carry around all their own scheduling information, and a pointer to the function that needs to be run; This information is mutable, allowing state machine behaviour with variable yet defined intervals between transitions to be employed. The firmware as it stands uses Processes to poll the rotary encoders on the drive motors, and calculate the instantaneous speeds of each wheel. A Process was also used to guarantee accurate timing for the Milestone 1 communications task. This architecture adds minimal overhead but verifiably gives an abstracted way of serially multitasking, as opposed to a very large loop function that risks control blocking and lock-ups.

Similarly, the parsing and execution of commands received over serial is handled by the `CommandSet' and `SerialCommand' classes, with function pointers being registered in association with the keyword string at setup time. Commands received over Serial are interpreted and executed immediately, giving very little lag between a command being sent and a command being enacted by the bot. These abstractions make it easy to add processes or new commands, and isolate potentially buggy functions from each-other (though any blocking IO operations will still break functionality). It is also possible to enable and disable processes during runtime, if it is desired. 

\subsection{Command Set}

All commands should be sent with a trailing newline, \verb|\n|

\begin{description}

\item[Ping]
  This is the simplest command the firmware responds to and should immediately receive a \verb|pong| back.

  send: \verb|ping|
  
  gets: \verb|pong|
  

\item[Toggle LED]
  Toggles the LED on/off. This will get overridden pretty quickly by the heartbeat blinking, but you can verify your connection this way too.

  send: \verb|L\n|
  
  gets: nothing

\item[Go] 
  Give the robot a $(x,y,\omega)$ vector and a power in the range 0 - 255, which it'll use to calculate and execute the holonomic motion in that direction. $x$ is the lateral (right +ve) direction, $y$ is the forward and $\omega$ is the rotational speed (anti-clockwise +ve). Note that the bot will always execute the motion at the maximum speed possible, so the \verb|rotate| command should be used for precise rotations. The bounds on the variables are undefined, as their relative magnitudes are used though the recommended range is $-1.0$ to $1.0$. \verb|G 0 0 0 0| or \verb|G| will stop the robot. If the fourth argument is omitted then it will default to 255 (full power).

  send: \verb|G %f1 %f2 %f3 %d4|

  gets: \verb|A|

  debug: \verb|Going|
  
\item[Move] 
  Tells the robot to apply power to the motors in the order 1 $>$ 2 $>$ 3. Valid range is -255 to 255 inclusive. \verb|M 0 0 0| or \verb|M| will stop the robot. This provides lower level / more direct control of the motors, and in general `Go' is preferable.

  send: \verb|M %d1 %d2 %d3|
  
  gets: \verb|A|

  debug: \verb|Moving|

  
\item[Force Stop]
  Force a stop. The robot will remove power from the motors immediately, without trying to do any clever `quick stop` by braking the motors. Generally a singular \verb|M| or \verb|G| will work better.
  
  send: \verb|S|

  gets: \verb|A|

  debug: \verb|Force stopping|

  
\item[Motor Speeds]
  Will print the instantaneous speeds of all three drive motors in bogounits (encoder stops per second) in the form:

  send: \verb|speeds|
  
  gets: \verb|0: n.nn 1: n.nn 2: n.nn|


\item[Grabbing]
  Opens or closes the grabber, depending on the argument given

  send: \verb|grab <0/1>|

  gets: \verb|A|

  debug: \verb|grabbing <0/1>\n done|


\item[Rotating]
  Rotates at \texttt{d1} power (-255 to 255 inclusive) until the encoders have gone through \texttt{d2} stops (0+) on average. This can be used to get fairly precise rotation but stops isn't degrees (though it's related) and depends somewhat on battery voltage.

  send: \verb|rotate %d1 %d2|

  gets: \verb|A|

  debug: \verb|rotating at %d1 to %d2 stops|


\item[Help]
  Prints the commands that the robot is listening for; this is always correct as it is generated on-the-fly from the Command Set parsing class. It won't print how many arguments it expects, but is useful for checking spelling or troubleshooting a \texttt{N} (NACK).

  The help command can also be used to verify that the command set is the one you're expecting.

  send: \verb|help|

  get: \verb|Valid input commands: (some have arguments)|\\
  (Each command will be printed on a new line, excluding the number of arguments)


\item[NACK]
  If the command is not recognised the bot will reply with a NACK:

  \verb|N - <unrecognised_command>|

\end{description}
